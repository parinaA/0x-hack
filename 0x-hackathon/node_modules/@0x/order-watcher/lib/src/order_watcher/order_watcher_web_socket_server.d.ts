import { ContractAddresses } from '@0x/contract-addresses';
import { Provider } from 'ethereum-types';
import { OrderWatcherConfig } from '../types';
export declare class OrderWatcherWebSocketServer {
    private readonly _orderWatcher;
    private readonly _httpServer;
    private readonly _connectionStore;
    private readonly _wsServer;
    private readonly _isVerbose;
    /**
     *  Recover types lost when the payload is stringified.
     */
    private static _parseSignedOrder;
    /**
     * Instantiate a new WebSocket server which provides OrderWatcher functionality
     *  @param provider Web3 provider to use for JSON RPC calls.
     *  @param networkId NetworkId to watch orders on.
     *  @param contractAddresses Optional contract addresses. Defaults to known
     *  addresses based on networkId.
     *  @param orderWatcherConfig OrderWatcher configurations. isVerbose sets the verbosity for the WebSocket server aswell.
     *  @param isVerbose Whether to enable verbose logging. Defaults to true.
     */
    constructor(provider: Provider, networkId: number, contractAddresses?: ContractAddresses, orderWatcherConfig?: Partial<OrderWatcherConfig>);
    /**
     * Activates the WebSocket server by subscribing to the OrderWatcher and
     * starting the WebSocket's HTTP server
     */
    start(): void;
    /**
     * Deactivates the WebSocket server by stopping the HTTP server from accepting
     * new connections and unsubscribing from the OrderWatcher
     */
    stop(): void;
    private _log;
    private _onMessageCallbackAsync;
    private _onCloseCallback;
    private _routeRequestAsync;
    /**
     * Broadcasts OrderState changes to ALL connected clients. At the moment,
     * we do not support clients subscribing to only a subset of orders. As such,
     * Client B will be notified of changes to an order that Client A added.
     */
    private _broadcastCallback;
}
//# sourceMappingURL=order_watcher_web_socket_server.d.ts.map