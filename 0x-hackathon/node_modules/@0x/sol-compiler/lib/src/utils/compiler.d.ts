/// <reference types="node" />
import { ContractSource, Resolver } from '@0x/sol-resolver';
import { ContractArtifact } from 'ethereum-types';
import * as solc from 'solc';
/**
 * Gets contract data on network or returns if an artifact does not exist.
 * @param artifactsDir Path to the artifacts directory.
 * @param contractName Name of contract.
 * @return Contract data on network or undefined.
 */
export declare function getContractArtifactIfExistsAsync(artifactsDir: string, contractName: string): Promise<ContractArtifact | void>;
/**
 * Creates a directory if it does not already exist.
 * @param artifactsDir Path to the directory.
 */
export declare function createDirIfDoesNotExistAsync(dirPath: string): Promise<void>;
/**
 * Searches Solidity source code for compiler version range.
 * @param  source Source code of contract.
 * @return Solc compiler version range.
 */
export declare function parseSolidityVersionRange(source: string): string;
/**
 * Normalizes the path found in the error message. If it cannot be normalized
 * the original error message is returned.
 * Example: converts 'base/Token.sol:6:46: Warning: Unused local variable'
 *          to 'Token.sol:6:46: Warning: Unused local variable'
 * This is used to prevent logging the same error multiple times.
 * @param  errMsg An error message from the compiled output.
 * @return The error message with directories truncated from the contract path.
 */
export declare function getNormalizedErrMsg(errMsg: string): string;
/**
 * Parses the contract source code and extracts the dendencies
 * @param  source Contract source code
 * @return List of dependendencies
 */
export declare function parseDependencies(contractSource: ContractSource): string[];
/**
 * Compiles the contracts and prints errors/warnings
 * @param resolver Resolver
 * @param solcInstance Instance of a solc compiler
 * @param standardInput Solidity standard JSON input
 */
export declare function compile(resolver: Resolver, solcInstance: solc.SolcInstance, standardInput: solc.StandardInput): solc.StandardOutput;
/**
 * Gets the source tree hash for a file and its dependencies.
 * @param fileName Name of contract file.
 */
export declare function getSourceTreeHash(resolver: Resolver, importPath: string): Buffer;
/**
 * For the given @param contractPath, populates JSON objects to be used in the ContractVersionData interface's
 * properties `sources` (source code file names mapped to ID numbers) and `sourceCodes` (source code content of
 * contracts) for that contract.  The source code pointed to by contractPath is read and parsed directly (via
 * `resolver.resolve().source`), as are its imports, recursively.  The ID numbers for @return `sources` are
 * taken from the corresponding ID's in @param fullSources, and the content for @return sourceCodes is read from
 * disk (via the aforementioned `resolver.source`).
 */
export declare function getSourcesWithDependencies(resolver: Resolver, contractPath: string, fullSources: {
    [sourceName: string]: {
        id: number;
    };
}): {
    sourceCodes: {
        [sourceName: string]: string;
    };
    sources: {
        [sourceName: string]: {
            id: number;
        };
    };
};
/**
 * Gets the solidity compiler instance and full version name. If the compiler is already cached - gets it from FS,
 * otherwise - fetches it and caches it.
 * @param solcVersion The compiler version. e.g. 0.5.0
 */
export declare function getSolcAsync(solcVersion: string): Promise<{
    solcInstance: solc.SolcInstance;
    fullSolcVersion: string;
}>;
/**
 * Solidity compiler emits the bytecode without a 0x prefix for a hex. This function fixes it if bytecode is present.
 * @param compiledContract The standard JSON output section for a contract. Geth modified in place.
 */
export declare function addHexPrefixToContractBytecode(compiledContract: solc.StandardContractOutput): void;
//# sourceMappingURL=compiler.d.ts.map