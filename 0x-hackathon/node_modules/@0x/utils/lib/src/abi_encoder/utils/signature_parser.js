"use strict";
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
var _ = require("lodash");
/**
 * Returns an array of DataItem's corresponding to the input signature.
 * A signature can be in two forms: '<DataItem.type>' or '(<DataItem1.type>, <DataItem2.type>, ...)
 * An example of the first form would be 'address' or 'uint256'
 * An example of the second form would be '(address, uint256)'
 * Signatures can also include a name field, for example: 'foo address' or '(foo address, bar uint256)'
 * @param signature of input DataItems
 * @return DataItems derived from input signature
 */
function generateDataItemsFromSignature(signature) {
    var e_1, _a;
    var trimmedSignature = signature;
    if (signature.startsWith('(')) {
        if (!signature.endsWith(')')) {
            throw new Error("Failed to generate data item. Must end with ')'");
        }
        trimmedSignature = signature.substr(1, signature.length - 2);
    }
    trimmedSignature += ',';
    var isCurrTokenArray = false;
    var currTokenArrayModifier = '';
    var isParsingArrayModifier = false;
    var currToken = '';
    var parenCount = 0;
    var currTokenName = '';
    var dataItems = [];
    try {
        for (var trimmedSignature_1 = __values(trimmedSignature), trimmedSignature_1_1 = trimmedSignature_1.next(); !trimmedSignature_1_1.done; trimmedSignature_1_1 = trimmedSignature_1.next()) {
            var char = trimmedSignature_1_1.value;
            // Tokenize the type string while keeping track of parentheses.
            switch (char) {
                case '(':
                    parenCount += 1;
                    currToken += char;
                    break;
                case ')':
                    parenCount -= 1;
                    currToken += char;
                    break;
                case '[':
                    if (parenCount === 0) {
                        isParsingArrayModifier = true;
                        isCurrTokenArray = true;
                        currTokenArrayModifier += '[';
                    }
                    else {
                        currToken += char;
                    }
                    break;
                case ']':
                    if (parenCount === 0) {
                        isParsingArrayModifier = false;
                        currTokenArrayModifier += ']';
                    }
                    else {
                        currToken += char;
                    }
                    break;
                case ' ':
                    if (parenCount === 0) {
                        currTokenName = currToken;
                        currToken = '';
                    }
                    else {
                        currToken += char;
                    }
                    break;
                case ',':
                    if (parenCount === 0) {
                        // Generate new DataItem from token
                        var components = currToken.startsWith('(') ? generateDataItemsFromSignature(currToken) : [];
                        var isTuple = !_.isEmpty(components);
                        var dataItem = { name: currTokenName, type: '' };
                        if (isTuple) {
                            dataItem.type = 'tuple';
                            dataItem.components = components;
                        }
                        else {
                            dataItem.type = currToken;
                        }
                        if (isCurrTokenArray) {
                            dataItem.type += currTokenArrayModifier;
                        }
                        dataItems.push(dataItem);
                        // reset token state
                        currTokenName = '';
                        currToken = '';
                        isCurrTokenArray = false;
                        currTokenArrayModifier = '';
                        break;
                    }
                    else {
                        currToken += char;
                        break;
                    }
                default:
                    if (isParsingArrayModifier) {
                        currTokenArrayModifier += char;
                    }
                    else {
                        currToken += char;
                    }
                    break;
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (trimmedSignature_1_1 && !trimmedSignature_1_1.done && (_a = trimmedSignature_1.return)) _a.call(trimmedSignature_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return dataItems;
}
exports.generateDataItemsFromSignature = generateDataItemsFromSignature;
//# sourceMappingURL=signature_parser.js.map