"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var subproviders_1 = require("@0x/subproviders");
var fs = require("fs");
var _ = require("lodash");
var constants_1 = require("./constants");
var env_1 = require("./env");
exports.web3Factory = {
    getRpcProvider: function (config) {
        if (config === void 0) { config = {}; }
        var provider = new subproviders_1.Web3ProviderEngine();
        var hasAddresses = _.isUndefined(config.hasAddresses) || config.hasAddresses;
        config.shouldUseFakeGasEstimate =
            _.isUndefined(config.shouldUseFakeGasEstimate) || config.shouldUseFakeGasEstimate;
        if (!hasAddresses) {
            provider.addProvider(new subproviders_1.EmptyWalletSubprovider());
        }
        if (config.shouldUseFakeGasEstimate) {
            provider.addProvider(new subproviders_1.FakeGasEstimateSubprovider(constants_1.constants.GAS_LIMIT));
        }
        var logger = {
            log: function (arg) {
                fs.appendFileSync('ganache.log', arg + "\n");
            },
        };
        var shouldUseInProcessGanache = !!config.shouldUseInProcessGanache;
        if (shouldUseInProcessGanache) {
            if (!_.isUndefined(config.rpcUrl)) {
                throw new Error('Cannot use both GanacheSubrovider and RPCSubprovider');
            }
            var shouldThrowErrorsOnGanacheRPCResponse = _.isUndefined(config.shouldThrowErrorsOnGanacheRPCResponse) ||
                config.shouldThrowErrorsOnGanacheRPCResponse;
            if (!_.isUndefined(config.ganacheDatabasePath)) {
                // Saving the snapshot to a local db. Ganache requires this directory to exist
                fs.mkdirSync(config.ganacheDatabasePath);
            }
            provider.addProvider(new subproviders_1.GanacheSubprovider({
                vmErrorsOnRPCResponse: shouldThrowErrorsOnGanacheRPCResponse,
                db_path: config.ganacheDatabasePath,
                gasLimit: constants_1.constants.GAS_LIMIT,
                logger: logger,
                verbose: env_1.env.parseBoolean(env_1.EnvVars.VerboseGanache),
                port: 8545,
                network_id: 50,
                mnemonic: 'concert load couple harbor equip island argue ramp clarify fence smart topic',
            }));
        }
        else {
            provider.addProvider(new subproviders_1.RPCSubprovider(config.rpcUrl || constants_1.constants.RPC_URL));
        }
        provider.start();
        return provider;
    },
};
//# sourceMappingURL=web3_factory.js.map