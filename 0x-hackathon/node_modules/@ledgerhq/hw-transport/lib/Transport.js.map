{"version":3,"sources":["../src/Transport.js"],"names":["getAltStatusMessage","TransportError","TransportStatusError","StatusCodes","PIN_REMAINING_ATTEMPTS","INCORRECT_LENGTH","COMMAND_INCOMPATIBLE_FILE_STRUCTURE","SECURITY_STATUS_NOT_SATISFIED","CONDITIONS_OF_USE_NOT_SATISFIED","INCORRECT_DATA","NOT_ENOUGH_MEMORY_SPACE","REFERENCED_DATA_NOT_FOUND","FILE_ALREADY_EXISTS","INCORRECT_P1_P2","INS_NOT_SUPPORTED","CLA_NOT_SUPPORTED","TECHNICAL_PROBLEM","OK","MEMORY_PROBLEM","NO_EF_SELECTED","INVALID_OFFSET","FILE_NOT_FOUND","INCONSISTENT_FILE","ALGORITHM_NOT_SUPPORTED","INVALID_KCV","CODE_NOT_INITIALIZED","ACCESS_CONDITION_NOT_FULFILLED","CONTRADICTION_SECRET_CODE_STATUS","CONTRADICTION_INVALIDATION","CODE_BLOCKED","MAX_VALUE_REACHED","GP_AUTH_FAILED","LICENSING","HALTED","code","message","id","name","stack","Error","prototype","statusCode","statusText","Object","keys","find","k","smsg","statusCodeStr","toString","Transport","debug","global","__ledgerDebug","exchangeTimeout","_events","send","cla","ins","p1","p2","data","Buffer","alloc","statusList","length","exchange","concat","from","response","sw","readUInt16BE","some","s","_appAPIlock","eventName","cb","on","removeListener","event","args","emit","console","log","self","methods","scrambleKey","methodName","decorateAppAPIMethod","f","ctx","e","assign","currentLock","Promise","reject","setScrambleKey","apply","openTimeout","listenTimeout","resolve","found","sub","listen","next","unsubscribe","listenTimeoutId","clearTimeout","open","descriptor","then","error","complete","ErrorMessage_NoDeviceFound","setTimeout","ErrorMessage_ListenTimeout"],"mappings":";;;;;;;;;QAkEgBA,mB,GAAAA,mB;QAuBAC,c,GAAAA,c;QAaAC,oB,GAAAA,oB;;AApGhB;;;;;;;;;;;;AAyBA;;;;;;;;AAvBA;;;;AAIA;;;;AAIA;;;AAOA;;AAcO,IAAMC,oCAAc;AACzBC,0BAAwB,MADC;AAEzBC,oBAAkB,MAFO;AAGzBC,uCAAqC,MAHZ;AAIzBC,iCAA+B,MAJN;AAKzBC,mCAAiC,MALR;AAMzBC,kBAAgB,MANS;AAOzBC,2BAAyB,MAPA;AAQzBC,6BAA2B,MARF;AASzBC,uBAAqB,MATI;AAUzBC,mBAAiB,MAVQ;AAWzBC,qBAAmB,MAXM;AAYzBC,qBAAmB,MAZM;AAazBC,qBAAmB,MAbM;AAczBC,MAAI,MAdqB;AAezBC,kBAAgB,MAfS;AAgBzBC,kBAAgB,MAhBS;AAiBzBC,kBAAgB,MAjBS;AAkBzBC,kBAAgB,MAlBS;AAmBzBC,qBAAmB,MAnBM;AAoBzBC,2BAAyB,MApBA;AAqBzBC,eAAa,MArBY;AAsBzBC,wBAAsB,MAtBG;AAuBzBC,kCAAgC,MAvBP;AAwBzBC,oCAAkC,MAxBT;AAyBzBC,8BAA4B,MAzBH;AA0BzBC,gBAAc,MA1BW;AA2BzBC,qBAAmB,MA3BM;AA4BzBC,kBAAgB,MA5BS;AA6BzBC,aAAW,MA7Bc;AA8BzBC,UAAQ;AA9BiB,CAApB;;AAiCA,SAASjC,mBAAT,CAA6BkC,IAA7B,EAAoD;AACzD,UAAQA,IAAR;AACE;AACA,SAAK,MAAL;AACE,aAAO,kBAAP;AACF,SAAK,MAAL;AACE,aAAO,sEAAP;AACF,SAAK,MAAL;AACE,aAAO,sDAAP;AACF,SAAK,MAAL;AACE,aAAO,uBAAP;AACF,SAAK,MAAL;AACE,aAAO,4BAAP;AAXJ;AAaA,MAAI,UAAUA,IAAV,IAAkBA,QAAQ,MAA9B,EAAsC;AACpC,WAAO,+BAAP;AACD;AACF;;AAED;;;;AAIO,SAASjC,cAAT,CAAwBkC,OAAxB,EAAyCC,EAAzC,EAAqD;AAC1D,OAAKC,IAAL,GAAY,gBAAZ;AACA,OAAKF,OAAL,GAAeA,OAAf;AACA,OAAKG,KAAL,GAAa,IAAIC,KAAJ,GAAYD,KAAzB;AACA,OAAKF,EAAL,GAAUA,EAAV;AACD;AACD;AACAnC,eAAeuC,SAAf,GAA2B,IAAID,KAAJ,EAA3B;;AAEA;;;;AAIO,SAASrC,oBAAT,CAA8BuC,UAA9B,EAAkD;AACvD,OAAKJ,IAAL,GAAY,sBAAZ;AACA,MAAMK,aACJC,OAAOC,IAAP,CAAYzC,WAAZ,EAAyB0C,IAAzB,CAA8B;AAAA,WAAK1C,YAAY2C,CAAZ,MAAmBL,UAAxB;AAAA,GAA9B,KACA,eAFF;AAGA,MAAMM,OAAO/C,oBAAoByC,UAApB,KAAmCC,UAAhD;AACA,MAAMM,gBAAgBP,WAAWQ,QAAX,CAAoB,EAApB,CAAtB;AACA,OAAKd,OAAL,uBAAiCY,IAAjC,YAA4CC,aAA5C;AACA,OAAKV,KAAL,GAAa,IAAIC,KAAJ,GAAYD,KAAzB;AACA,OAAKG,UAAL,GAAkBA,UAAlB;AACA,OAAKC,UAAL,GAAkBA,UAAlB;AACD;AACD;AACAxC,qBAAqBsC,SAArB,GAAiC,IAAID,KAAJ,EAAjC;;AAEA;;;;;;IAKqBW,S;;;;;;SACnBC,K,GAAgCC,OAAOC,aAAP,IAAwB,I;SACxDC,e,GAA0B,K;SA0E1BC,O,GAAU,sB;;SAmDVC,I;yEAAO,iBACLC,GADK,EAELC,GAFK,EAGLC,EAHK,EAILC,EAJK;AAAA,YAKLC,IALK,uEAKUC,OAAOC,KAAP,CAAa,CAAb,CALV;AAAA,YAMLC,UANK,uEAMuB,CAAC7D,YAAYc,EAAb,CANvB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,sBAQD4C,KAAKI,MAAL,IAAe,GARd;AAAA;AAAA;AAAA;;AAAA,sBASG,IAAIhE,cAAJ,CACJ,8CAA8C4D,KAAKI,MAD/C,EAEJ,kBAFI,CATH;;AAAA;AAAA;AAAA,uBAckB,MAAKC,QAAL,CACrBJ,OAAOK,MAAP,CAAc,CACZL,OAAOM,IAAP,CAAY,CAACX,GAAD,EAAMC,GAAN,EAAWC,EAAX,EAAeC,EAAf,CAAZ,CADY,EAEZE,OAAOM,IAAP,CAAY,CAACP,KAAKI,MAAN,CAAZ,CAFY,EAGZJ,IAHY,CAAd,CADqB,CAdlB;;AAAA;AAcCQ,wBAdD;AAqBCC,kBArBD,GAqBMD,SAASE,YAAT,CAAsBF,SAASJ,MAAT,GAAkB,CAAxC,CArBN;;AAAA,oBAsBAD,WAAWQ,IAAX,CAAgB;AAAA,yBAAKC,MAAMH,EAAX;AAAA,iBAAhB,CAtBA;AAAA;AAAA;AAAA;;AAAA,sBAuBG,IAAIpE,oBAAJ,CAAyBoE,EAAzB,CAvBH;;AAAA;AAAA,iDAyBED,QAzBF;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;SA6FPK,W,GAAc,I;;;AAxNd;;;;;AAKA;;;;;;;;AAQA;;;;;;;;;;;;;;;;;;;;;;AAwBA;;;;;;;;;;AAaA;;;;;;;;;AASA;;;;;;;AAOA;;;;;;;;;;AAQA;;;;;uBAKGC,S,EAAmBC,E,EAAc;AAClC,WAAKrB,OAAL,CAAasB,EAAb,CAAgBF,SAAhB,EAA2BC,EAA3B;AACD;;AAED;;;;;;wBAGID,S,EAAmBC,E,EAAc;AACnC,WAAKrB,OAAL,CAAauB,cAAb,CAA4BH,SAA5B,EAAuCC,EAAvC;AACD;;;yBAEIG,K,EAA2B;AAAA;;AAAA,wCAATC,IAAS;AAATA,YAAS;AAAA;;AAC9B,sBAAKzB,OAAL,EAAa0B,IAAb,iBAAkBF,KAAlB,4BAA4BC,IAA5B;AACD;;AAED;;;;;;iCAGa7B,K,EAA0C;AACrD,WAAKA,KAAL,GACE,OAAOA,KAAP,KAAiB,UAAjB,GACIA,KADJ,GAEIA,QACE;AAAA,eAAO+B,QAAQC,GAAR,CAAYA,GAAZ,CAAP;AAAA,OADF,GAEE,IALR;AAMD;;AAED;;;;;;uCAGmB7B,e,EAAyB;AAC1C,WAAKA,eAAL,GAAuBA,eAAvB;AACD;;AAED;;;;;;;;;;;;;0CAyFE8B,I,EACAC,O,EACAC,W,EACA;AAAA;AAAA;AAAA;;AAAA;AACA,6BAAuBD,OAAvB,8HAAgC;AAAA,cAAvBE,UAAuB;;AAC9BH,eAAKG,UAAL,IAAmB,KAAKC,oBAAL,CACjBD,UADiB,EAEjBH,KAAKG,UAAL,CAFiB,EAGjBH,IAHiB,EAIjBE,WAJiB,CAAnB;AAMD;AARD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AASD;;;yCAICC,U,EACAE,C,EACAC,G,EACAJ,W,EAC4B;AAAA;;AAC5B;AAAA,4EAAO;AAAA,6CAAUN,IAAV;AAAUA,gBAAV;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AACGN,6BADH,UACGA,WADH;;AAAA,uBAEDA,WAFC;AAAA;AAAA;AAAA;;AAGGiB,oBAHH,GAGO,IAAI1F,cAAJ,CACR,iCAAiCyE,WAAjC,GAA+C,GADvC,EAER,iBAFQ,CAHP;;AAOH/B,yBAAOiD,MAAP,CAAcD,EAAd,EAAiB;AACfE,iCAAanB,WADE;AAEfa;AAFe,mBAAjB;AAPG,oDAWIO,QAAQC,MAAR,CAAeJ,EAAf,CAXJ;;AAAA;AAAA;;AAcH,yBAAKjB,WAAL,GAAmBa,UAAnB;AACA,yBAAKS,cAAL,CAAoBV,WAApB;AAfG;AAAA,yBAgBUG,EAAEQ,KAAF,CAAQP,GAAR,EAAaV,IAAb,CAhBV;;AAAA;AAAA;;AAAA;AAAA;;AAkBH,yBAAKN,WAAL,GAAmB,IAAnB;AAlBG;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SAAP;;AAAA;AAAA;AAAA;AAAA;AAqBD;;;;;AA7FD;;;;;;;6BAUkC;AAAA;;AAAA,UAFhCwB,WAEgC,uEAFT,IAES;AAAA,UADhCC,aACgC;;AAChC,aAAO,IAAIL,OAAJ,CAAY,UAACM,OAAD,EAAUL,MAAV,EAAqB;AACtC,YAAIM,QAAQ,KAAZ;AACA,YAAMC,MAAM,OAAKC,MAAL,CAAY;AACtBC,gBAAM,iBAAK;AACTH,oBAAQ,IAAR;AACA,gBAAIC,GAAJ,EAASA,IAAIG,WAAJ;AACT,gBAAIC,eAAJ,EAAqBC,aAAaD,eAAb;AACrB,mBAAKE,IAAL,CAAUjB,EAAEkB,UAAZ,EAAwBX,WAAxB,EAAqCY,IAArC,CAA0CV,OAA1C,EAAmDL,MAAnD;AACD,WANqB;AAOtBgB,iBAAO,kBAAK;AACV,gBAAIL,eAAJ,EAAqBC,aAAaD,eAAb;AACrBX,mBAAOJ,CAAP;AACD,WAVqB;AAWtBqB,oBAAU,oBAAM;AACd,gBAAIN,eAAJ,EAAqBC,aAAaD,eAAb;AACrB,gBAAI,CAACL,KAAL,EAAY;AACVN,qBACE,IAAI9F,cAAJ,CACE,OAAKgH,0BADP,EAEE,eAFF,CADF;AAMD;AACF;AArBqB,SAAZ,CAAZ;AAuBA,YAAMP,kBAAkBP,gBACpBe,WAAW,YAAM;AACfZ,cAAIG,WAAJ;AACAV,iBACE,IAAI9F,cAAJ,CACE,OAAKkH,0BADP,EAEE,eAFF,CADF;AAMD,SARD,EAQGhB,aARH,CADoB,GAUpB,IAVJ;AAWD,OApCM,CAAP;AAqCD;;;;;;AA3MkBjD,S,CA0PZiE,0B,GAA6B,kC;AA1PjBjE,S,CA2PZ+D,0B,GAA6B,wB;kBA3PjB/D,S","file":"Transport.js","sourcesContent":["//@flow\n\nimport EventEmitter from \"events\";\n\n/**\n */\nexport type Subscription = { unsubscribe: () => void };\n\n/**\n */\nexport type Device = Object;\n\n/**\n */\nexport type DescriptorEvent<Descriptor> = {\n  type: \"add\" | \"remove\",\n  descriptor: Descriptor,\n  device?: Device\n};\n/**\n */\nexport type Observer<Ev> = $ReadOnly<{\n  next: (event: Ev) => mixed,\n  error: (e: any) => mixed,\n  complete: () => mixed\n}>;\n\n/**\n * all possible status codes.\n * @see https://github.com/LedgerHQ/blue-app-btc/blob/d8a03d10f77ca5ef8b22a5d062678eef788b824a/include/btchip_apdu_constants.h#L85-L115\n * @example\n * import { StatusCodes } from \"@ledgerhq/hw-transport\";\n */\nexport const StatusCodes = {\n  PIN_REMAINING_ATTEMPTS: 0x63c0,\n  INCORRECT_LENGTH: 0x6700,\n  COMMAND_INCOMPATIBLE_FILE_STRUCTURE: 0x6981,\n  SECURITY_STATUS_NOT_SATISFIED: 0x6982,\n  CONDITIONS_OF_USE_NOT_SATISFIED: 0x6985,\n  INCORRECT_DATA: 0x6a80,\n  NOT_ENOUGH_MEMORY_SPACE: 0x6a84,\n  REFERENCED_DATA_NOT_FOUND: 0x6a88,\n  FILE_ALREADY_EXISTS: 0x6a89,\n  INCORRECT_P1_P2: 0x6b00,\n  INS_NOT_SUPPORTED: 0x6d00,\n  CLA_NOT_SUPPORTED: 0x6e00,\n  TECHNICAL_PROBLEM: 0x6f00,\n  OK: 0x9000,\n  MEMORY_PROBLEM: 0x9240,\n  NO_EF_SELECTED: 0x9400,\n  INVALID_OFFSET: 0x9402,\n  FILE_NOT_FOUND: 0x9404,\n  INCONSISTENT_FILE: 0x9408,\n  ALGORITHM_NOT_SUPPORTED: 0x9484,\n  INVALID_KCV: 0x9485,\n  CODE_NOT_INITIALIZED: 0x9802,\n  ACCESS_CONDITION_NOT_FULFILLED: 0x9804,\n  CONTRADICTION_SECRET_CODE_STATUS: 0x9808,\n  CONTRADICTION_INVALIDATION: 0x9810,\n  CODE_BLOCKED: 0x9840,\n  MAX_VALUE_REACHED: 0x9850,\n  GP_AUTH_FAILED: 0x6300,\n  LICENSING: 0x6f42,\n  HALTED: 0x6faa\n};\n\nexport function getAltStatusMessage(code: number): ?string {\n  switch (code) {\n    // improve text of most common errors\n    case 0x6700:\n      return \"Incorrect length\";\n    case 0x6982:\n      return \"Security not satisfied (dongle locked or have invalid access rights)\";\n    case 0x6985:\n      return \"Condition of use not satisfied (denied by the user?)\";\n    case 0x6a80:\n      return \"Invalid data received\";\n    case 0x6b00:\n      return \"Invalid parameter received\";\n  }\n  if (0x6f00 <= code && code <= 0x6fff) {\n    return \"Internal error, please report\";\n  }\n}\n\n/**\n * TransportError is used for any generic transport errors.\n * e.g. Error thrown when data received by exchanges are incorrect or if exchanged failed to communicate with the device for various reason.\n */\nexport function TransportError(message: string, id: string) {\n  this.name = \"TransportError\";\n  this.message = message;\n  this.stack = new Error().stack;\n  this.id = id;\n}\n//$FlowFixMe\nTransportError.prototype = new Error();\n\n/**\n * Error thrown when a device returned a non success status.\n * the error.statusCode is one of the `StatusCodes` exported by this library.\n */\nexport function TransportStatusError(statusCode: number) {\n  this.name = \"TransportStatusError\";\n  const statusText =\n    Object.keys(StatusCodes).find(k => StatusCodes[k] === statusCode) ||\n    \"UNKNOWN_ERROR\";\n  const smsg = getAltStatusMessage(statusCode) || statusText;\n  const statusCodeStr = statusCode.toString(16);\n  this.message = `Ledger device: ${smsg} (0x${statusCodeStr})`;\n  this.stack = new Error().stack;\n  this.statusCode = statusCode;\n  this.statusText = statusText;\n}\n//$FlowFixMe\nTransportStatusError.prototype = new Error();\n\n/**\n * Transport defines the generic interface to share between node/u2f impl\n * A **Descriptor** is a parametric type that is up to be determined for the implementation.\n * it can be for instance an ID, an file path, a URL,...\n */\nexport default class Transport<Descriptor> {\n  debug: ?(log: string) => void = global.__ledgerDebug || null;\n  exchangeTimeout: number = 30000;\n\n  /**\n   * Statically check if a transport is supported on the user's platform/browser.\n   */\n  static +isSupported: () => Promise<boolean>;\n\n  /**\n   * List once all available descriptors. For a better granularity, checkout `listen()`.\n   * @return a promise of descriptors\n   * @example\n   * TransportFoo.list().then(descriptors => ...)\n   */\n  static +list: () => Promise<Array<Descriptor>>;\n\n  /**\n   * Listen all device events for a given Transport. The method takes an Obverver of DescriptorEvent and returns a Subscription (according to Observable paradigm https://github.com/tc39/proposal-observable )\n   * a DescriptorEvent is a `{ descriptor, type }` object. type can be `\"add\"` or `\"remove\"` and descriptor is a value you can pass to `open(descriptor)`.\n   * each listen() call will first emit all potential device already connected and then will emit events can come over times,\n   * for instance if you plug a USB device after listen() or a bluetooth device become discoverable.\n   * @param observer is an object with a next, error and complete function (compatible with observer pattern)\n   * @return a Subscription object on which you can `.unsubscribe()` to stop listening descriptors.\n   * @example\nconst sub = TransportFoo.listen({\n  next: e => {\n    if (e.type===\"add\") {\n      sub.unsubscribe();\n      const transport = await TransportFoo.open(e.descriptor);\n      ...\n    }\n  },\n  error: error => {},\n  complete: () => {}\n})\n   */\n  static +listen: (\n    observer: Observer<DescriptorEvent<Descriptor>>\n  ) => Subscription;\n\n  /**\n   * attempt to create a Transport instance with potentially a descriptor.\n   * @param descriptor: the descriptor to open the transport with.\n   * @param timeout: an optional timeout\n   * @return a Promise of Transport instance\n   * @example\nTransportFoo.open(descriptor).then(transport => ...)\n   */\n  static +open: (\n    descriptor: Descriptor,\n    timeout?: number\n  ) => Promise<Transport<Descriptor>>;\n\n  /**\n   * low level api to communicate with the device\n   * This method is for implementations to implement but should not be directly called.\n   * Instead, the recommanded way is to use send() method\n   * @param apdu the data to send\n   * @return a Promise of response data\n   */\n  +exchange: (apdu: Buffer) => Promise<Buffer>;\n\n  /**\n   * set the \"scramble key\" for the next exchanges with the device.\n   * Each App can have a different scramble key and they internally will set it at instanciation.\n   * @param key the scramble key\n   */\n  +setScrambleKey: (key: string) => void;\n\n  /**\n   * close the exchange with the device.\n   * @return a Promise that ends when the transport is closed.\n   */\n  +close: () => Promise<void>;\n\n  _events = new EventEmitter();\n\n  /**\n   * Listen to an event on an instance of transport.\n   * Transport implementation can have specific events. Here is the common events:\n   * * `\"disconnect\"` : triggered if Transport is disconnected\n   */\n  on(eventName: string, cb: Function) {\n    this._events.on(eventName, cb);\n  }\n\n  /**\n   * Stop listening to an event on an instance of transport.\n   */\n  off(eventName: string, cb: Function) {\n    this._events.removeListener(eventName, cb);\n  }\n\n  emit(event: string, ...args: *) {\n    this._events.emit(event, ...args);\n  }\n\n  /**\n   * Enable or not logs of the binary exchange\n   */\n  setDebugMode(debug: boolean | ((log: string) => void)) {\n    this.debug =\n      typeof debug === \"function\"\n        ? debug\n        : debug\n          ? log => console.log(log)\n          : null;\n  }\n\n  /**\n   * Set a timeout (in milliseconds) for the exchange call. Only some transport might implement it. (e.g. U2F)\n   */\n  setExchangeTimeout(exchangeTimeout: number) {\n    this.exchangeTimeout = exchangeTimeout;\n  }\n\n  /**\n   * wrapper on top of exchange to simplify work of the implementation.\n   * @param cla\n   * @param ins\n   * @param p1\n   * @param p2\n   * @param data\n   * @param statusList is a list of accepted status code (shorts). [0x9000] by default\n   * @return a Promise of response buffer\n   */\n  send = async (\n    cla: number,\n    ins: number,\n    p1: number,\n    p2: number,\n    data: Buffer = Buffer.alloc(0),\n    statusList: Array<number> = [StatusCodes.OK]\n  ): Promise<Buffer> => {\n    if (data.length >= 256) {\n      throw new TransportError(\n        \"data.length exceed 256 bytes limit. Got: \" + data.length,\n        \"DataLengthTooBig\"\n      );\n    }\n    const response = await this.exchange(\n      Buffer.concat([\n        Buffer.from([cla, ins, p1, p2]),\n        Buffer.from([data.length]),\n        data\n      ])\n    );\n    const sw = response.readUInt16BE(response.length - 2);\n    if (!statusList.some(s => s === sw)) {\n      throw new TransportStatusError(sw);\n    }\n    return response;\n  };\n\n  /**\n   * create() allows to open the first descriptor available or\n   * throw if there is none or if timeout is reached.\n   * This is a light helper, alternative to using listen() and open() (that you may need for any more advanced usecase)\n   * @example\nTransportFoo.create().then(transport => ...)\n   */\n  static create(\n    openTimeout?: number = 3000,\n    listenTimeout?: number\n  ): Promise<Transport<Descriptor>> {\n    return new Promise((resolve, reject) => {\n      let found = false;\n      const sub = this.listen({\n        next: e => {\n          found = true;\n          if (sub) sub.unsubscribe();\n          if (listenTimeoutId) clearTimeout(listenTimeoutId);\n          this.open(e.descriptor, openTimeout).then(resolve, reject);\n        },\n        error: e => {\n          if (listenTimeoutId) clearTimeout(listenTimeoutId);\n          reject(e);\n        },\n        complete: () => {\n          if (listenTimeoutId) clearTimeout(listenTimeoutId);\n          if (!found) {\n            reject(\n              new TransportError(\n                this.ErrorMessage_NoDeviceFound,\n                \"NoDeviceFound\"\n              )\n            );\n          }\n        }\n      });\n      const listenTimeoutId = listenTimeout\n        ? setTimeout(() => {\n            sub.unsubscribe();\n            reject(\n              new TransportError(\n                this.ErrorMessage_ListenTimeout,\n                \"ListenTimeout\"\n              )\n            );\n          }, listenTimeout)\n        : null;\n    });\n  }\n\n  decorateAppAPIMethods(\n    self: Object,\n    methods: Array<string>,\n    scrambleKey: string\n  ) {\n    for (let methodName of methods) {\n      self[methodName] = this.decorateAppAPIMethod(\n        methodName,\n        self[methodName],\n        self,\n        scrambleKey\n      );\n    }\n  }\n\n  _appAPIlock = null;\n  decorateAppAPIMethod<R, A: any[]>(\n    methodName: string,\n    f: (...args: A) => Promise<R>,\n    ctx: *,\n    scrambleKey: string\n  ): (...args: A) => Promise<R> {\n    return async (...args) => {\n      const { _appAPIlock } = this;\n      if (_appAPIlock) {\n        const e = new TransportError(\n          \"Ledger Device is busy (lock \" + _appAPIlock + \")\",\n          \"TransportLocked\"\n        );\n        Object.assign(e, {\n          currentLock: _appAPIlock,\n          methodName\n        });\n        return Promise.reject(e);\n      }\n      try {\n        this._appAPIlock = methodName;\n        this.setScrambleKey(scrambleKey);\n        return await f.apply(ctx, args);\n      } finally {\n        this._appAPIlock = null;\n      }\n    };\n  }\n\n  static ErrorMessage_ListenTimeout = \"No Ledger device found (timeout)\";\n  static ErrorMessage_NoDeviceFound = \"No Ledger device found\";\n}\n"]}